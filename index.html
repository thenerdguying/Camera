<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Camera</title>
    <style>
        :root {
            --pixel-blue: #8ab4a89dc;
            --pixel-green: #81c995;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: 'Google Sans', Arial, sans-serif;
            background: linear-gradient(135deg, #121212, #000000);
            color: black;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #camera-container {
            width: 100%;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            position: relative;
            overflow: hidden;
            background: radial-gradient(circle at center, #121212, #000);
        }
        
        video {
            width: 100%;
            height: 100%;
            min-height: 100%;
            object-fit: cover;

            /* Improved video quality */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            will-change: transform;
        }
        
        canvas {
            display: none;
        }
        
        #controls {
            width: 100%;
            padding: 16px;
            gap: 12px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 24px 24px 0 0;
            position: fixed;
            bottom: 0;
        }
        
        .control-buttonsons {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 16px;
        }
        
        .camera-button {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .camera-button:hover, .camera-button:focus {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .camera-button:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.05);
        }

        #capture-button {
            width: 64px;
            height: 64px;
            background: black;
            border: 4px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 2px 16px rgba(0, 0, 0, 0.3);
        }

        #capture-button:active {
            background: #f5f5f5;
        }

        .right-controls {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        #gallery-button svg {
            width: 24px;
            height: 24px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        #switch-camera svg {
            width: 24px;
            height: 24px;
        }

        #mode-buttons {
            display: flex;
            gap: 1rem;
        }
        
        .video-recording {
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        #gallery-button {
            position: absolute;
            top: 1rem;
            right: 1rem;
        }
        .camera-button svg {
            width: 24px;
            height: 24px;
            fill: white;
            transition: all 0.2s ease;
        }

        #capture-button svg {
            width: 20px;
            height: 20px;
            fill: #33B5E5;
        }

        #mode-buttons button {
            color: white;
            background: transparent;
            border: none;
            font-size: 14px;
            padding: 8px 12px;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #mode-buttons button.active {
            background: rgba(255, 255, 255, 0.15);
        }

        #flash-button.active svg {
            fill: var(--pixel-blue);
        }

        #switch-camera svg {
            transform: rotate(0deg);
            transition: transform 0.3s ease;
        }

        #switch-camera.back svg {
            transform: rotate(180deg);
        }

        /* Add gallery modal styles */
        #gallery-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #gallery-content {
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            background: #1e1e1e;
            border-radius: 12px;
            padding: 16px;
        }

        .gallery-item {
            width: 100%;
            margin-bottom: 12px;
            border-radius: 8px;
            overflow: hidden;
        }

        .gallery-item img {
            width: 100%;
            display: block;
        }

        #close-gallery {
            position: absolute;
            top: 16px;
            right: 16px;
            color: white;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
        }

        /* Add zoom controls */
        #zoom-controls {
            position: absolute;
            bottom: 180px;
            right: 24px;
            z-index: 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(16px);
            border-radius: 16px;
            padding: 16px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .zoom-button {
            width: 48px;
            height: 48px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .zoom-button:active, .zoom-button:hover {
            background: rgba(255, 255, 255, 0);
        }

        #zoom-slider {
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            width: 8px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 0;
        }

        #zoom-display {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border-radius: 32px;
            font-size: 14px;
            font-weight: medium;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .user-header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 100;
            display: flex;
            justify-content: space-between;
        }

        .login-button {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 24px;
            color: #fff;
            border: none;
            font-size: 14px;
            padding: 8px 16px;
            cursor: pointer;
        }
        
        /* Add focus styles */
        #camera-container {
            position: relative;
        }
        
        .focus-indicator {
            position: absolute;
        }
    </style>
</head>
<body>
    <div class="user-header">
        <span id="user-display"></span>
        <button id="login-button" class="login-button">
            Sign In
        </button>
    </div>
    <div id="camera-container">
        <video id="video" autoplay playsinline></video>
        <canvas id="canvas"></canvas>
        
        <div id="gallery-button" title="Gallery" class="camera-button">
            <svg viewBox="0 0 24 24">
                <path d="M3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5c0-1.1-0.9-2,2-2H5C3.9,3,3,3.9,3,5z M8,5h2v2H8V5z M11,5h2v2h-2V5z M14,5h2v2h-2V5z M17,5h2v2h-2V5z M5,7h2v2H5V7z M5,10h2v2H5V10z M5,13h2v2H5V13z M5,16h2v2H5V16z M17,17v2h-2v-2H17z M14,17v2h-2v-2H14z M11,17v2H9v-2H11z M19,7v2h-2V7H19z M19,10v2h-2v-2H19z M19,13v2h-2v-2H19z M19,16v2h-2v-2H19z"/>
            </svg>
        </div>
        <!-- Zoom controls -->
        <div id="zoom-controls">
            <span id="zoom-display">1x</span>
            <button class="zoom-button" id="zoom-in">+</button>
            <input type="range" id="zoom-slider" min="1" max="10" step="0.5" value="1">
            <button class="zoom-button" id="zoom-out">-</button>
        </div>
    </div>
    
    <div id="controls">
        <div class="control-buttonsons">
            <div id="mode-buttons">
                <button class="active" id="photo-mode">Photo</button>
                <button id="video-mode">Video</button>
            </div>
            <div id="capture-container">
                <button id="capture-button" class="camera-button" data-mode="photo">
                    <svg viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="10"/>
                    </svg>
                </button>
            </div>
            <div class="right-controls">
                <button id="flash-button" class="camera-button" title="Flash">
                    <svg viewBox="0 0 24 24">
                        <path d="M7,2v11h3v9l7-12h-4l4-8H7z M10,11V4.1l1.8,3.8H11v3H10z"/>
                    </svg>
                </button>
                <button id="switch-camera" class="camera-button" title="Switch Camera">
                    <svg viewBox="0 0 24 24">
                        <path d="M20,4h-3.2L15,2H9L7.2,4H4A2,2,0,0,0,2,6V18a2,2,0,0,0,2,2H20a2,2,0,0,0,2-2V6A2,2,0,0,0,20,4Zm0,14H4V6H8.4l1.8-2h3.6l1.8,2H20V18ZM12,7a5,5,0,1,0,5,5A5,5,0,0,0,12,7Zm0,8a3,3,0,1,1,3-3A3,3,0,0,1,12,15Z"/>
                    </svg>
                </button>
                <button id="focus-button" class="camera-button" title="Auto Focus">
                    <svg viewBox="0 0 24 24">
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Add gallery modal -->
    <div id="gallery-modal">
        <button id="close-gallery">✕</button>
        <div id="gallery-content"></div>
    </div>

    <script>
        const videoEl = document.getElementById('video');
        const captureButton = document.getElementById('capture-button');
        const switchCameraButton = document.getElementById('switch-camera');
        let mediaStream = null;
        let currentFacingMode = 'environment';
        let captures = [];
        let recording = false;
        let mediaRecorder = null;
        let recordedChunks = [];

        // Optimized variables
        let focusInterval = null;
        let focusActive = false;

        async function handleCameraError(error) {
            console.error('Camera error:', error);
            const errorMessage = typeof error === 'string' ? error : 'Could not access camera.';
            document.getElementById('user-display').textContent = errorMessage;
        }

        async function startCameraWithRetry() {
            let maxTries = 3;
            for (let i = 0; i < maxTries; i++) {
                try {
                    await initCamera();
                    return;
                } catch (e) {
                    console.log(`Retry ${i}: Camera initialization failed`);
                    if (i === maxTries - 1) {
                        handleCameraError(e);
                    }
                }
                await new Promise(r => setTimeout(r, 1000));
            }
        }

        async function initCamera() {
            try {
                const constraints = {
                    video: {
                        facingMode: currentFacingMode,
                        advanced: [{
                            width: window.innerWidth,
                            height: window.innerHeight,
                            aspectRatio: window.innerWidth / window.innerHeight,
                            frameRate: 30
                        }]
                    }
                };

                // Clean up previous resources
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => {
                        track.stop();
                        track.enabled = false; 
                    });
                }

                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                videoEl.srcObject = mediaStream;

                return true;
            } catch (e) {
                console.error('Camera error:', e);
                return false; 
            } finally {
                // Free mem
                requestAnimationFrame(() => { 
                    // cleanup logic
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            startCameraWithRetry().then(() => {
                initGallery();
            }).catch(() => {
                handleCameraError();
            });
        });

        // Initialize video mode
        function initMode() {
            document.getElementById('photo-mode').classList.add('active');
            document.getElementById('video-mode').classList.remove('active');
            captureButton.setAttribute('data-mode', 'photo');
        }

        // Mode button event listeners
        document.querySelectorAll('#mode-buttons button').forEach((button) => {
            button.addEventListener('click', () => {
                const mode = button.id.replace('-mode', '');
                setMode(mode);
            });
        });

        // Function to set mode
        function setMode(mode) {
            document.querySelectorAll('#mode-buttons .active').forEach((element) => element.classList.remove('active'));
            document.getElementById(`${mode}-mode`).classList.add('active');

            captureButton.setAttribute('data-mode', mode);
        }

        // Switch camera between front/rear
        switchCameraButton.addEventListener('click', () => {
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            updateCameraButton();
            startCameraWithRetry();
        });

        // Capture functionality
        captureButton.addEventListener('click', () => {
            if (captureButton.getAttribute('data-mode') === 'photo') {
                takePhoto();
            } else {
                toggleRecording();
            }
        });

        // Enhanced photo capture with better quality
        function takePhoto() {
            try {
                const quality = 0.92; // Higher quality JPEG
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                
                // Use full resolution
                canvas.width = videoEl.videoWidth;
                canvas.height = videoEl.videoHeight;

                // Draw with smoothing but preserve sharpness
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(videoEl, 0, 0, canvas.width, canvas.height);

                // Simple auto-enhance effects
                ctx.globalCompositeOperation = 'luminosity';
                ctx.filter = 'contrast(1.1) brightness(1.05) saturate(1.2)';
                ctx.drawImage(canvas, 0, 0);
                ctx.globalCompositeOperation = 'source-over';
                ctx.filter = 'none';

                // Higher quality export
                const imageData = canvas.toDataURL('image/jpeg', quality);

                // Sync with WebSim
                const captureObj = {
                    url: imageData,
                    timestamp: new Date(),
                    quality: quality
                };
                captures.unshift(captureObj);

                savePhotoToProject(null, imageData);

                // Flash effect
                showFlashFeedback();

            } catch (e) {
                console.error('Error taking photo:', e);
            }
        }

        // Video recording functionality
        function toggleRecording() {
            if (recording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        async function startRecording() {
            try {
                const stream = videoEl.srcObject;
                mediaRecorder = new MediaRecorder(stream);
                
                recordedChunks = [];

                mediaRecorder.ondataavailable = (e) => {
                    recordedChunks.push(e.data);
                };

                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/mp4' });
                    const videoURL = URL.createObjectURL(blob);
                    const captureObj = {
                        url: videoURL,
                        timestamp: new Date()
                    };
                    captures.unshift(captureObj);

                    saveVideoToProject(null, blob);
                };

                mediaRecorder.start(1 / 30);
                recording = true;
                document.getElementById('capture-button').classList.add('video-recording');
            } catch (e) {
                console.error('Error starting recording:', e);
            }
        }

        function stopRecording() {
            if (mediaRecorder) {
                mediaRecorder.stop();
                recording = false;
                document.getElementById('capture-button').classList.remove('video-recording');
            }
        }

        // Update switch camera button class based on current facing mode
        const updateCameraButton = () => {
            switchCameraButton.classList.toggle('back', currentFacingMode === 'user');
        };

        // Initial button state
        updateCameraButton();

        // Improved zoom functionality
        const ZOOM_MIN = 1;
        const ZOOM_MAX = 10;
        const ZOOM_STEP = 0.5;
        let currentZoom = 1;

        function applyZoom(zoom) {
            currentZoom = Math.max(ZOOM_MIN, Math.min(zoom, ZOOM_MAX));

            // Apply to both digital and optical zoom if available
            const videoTrack = videoEl.srcObject?.getVideoTracks()[0];
            if (videoTrack) {
                const capabilities = videoTrack.getCapabilities();
                
                if (capabilities.zoom) {
                    try {
                        const zoomRange = capabilities.zoom.max - capabilities.zoom.min;
                        const targetZoom = zoom / ZOOM_MAX * zoomRange + capabilities.zoom.min;
                        videoTrack.applyConstraints({ 
                            advanced: [ { zoom: targetZoom } ],
                            video: {
                                width: { ideal: Math.min(window.innerWidth * currentZoom, 1920) },
                                height: { ideal: Math.min(window.innerHeight * currentZoom, 1080) }
                            }
                        });

                        // Enhanced viewfinder scaling
                        videoEl.style.transform = `scale(${1 + ((currentZoom-1)*0.3)})`;
                        videoEl.style.transformOrigin = 'center center';
                        videoEl.style.transition = 'transform 0.2s cubic-bezier(0.4, 0, 0.2, 1)';

                    } catch (e) {
                        console.warn('Optical zoom not supported, using digital zoom');
                        // Fallback to digital zoom
                        videoEl.style.transform = `scale(${currentZoom})`;
                    }
                } else {
                    // Digital zoom fallback
                    videoEl.style.transform = `scale(${currentZoom})`;
                }
            }

            // Update UI
            zoomSlider.value = currentZoom;
            zoomDisplay.textContent = `${currentZoom.toFixed(1)}x`;

            // Smooth zoom animation for mobile
            if ('ontouchstart' in window) {
                videoEl.style.transition = 'transform 0.15s ease-out';
                setTimeout(() => {
                    videoEl.style.transition = '';
                }, 150);
            }
        } 

        // Zoom button handlers
        const zoomInButton = document.getElementById('zoom-in');
        const zoomOutButton = document.getElementById('zoom-out');
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomDisplay = document.getElementById('zoom-display');

        zoomInButton.addEventListener('click', () => {
            applyZoom(currentZoom + ZOOM_STEP);
        });

        zoomOutButton.addEventListener('click', () => {
            applyZoom(currentZoom - ZOOM_STEP);
        });

        zoomSlider.addEventListener('input', (e) => {
            applyZoom(parseFloat(e.target.value));
        });

        // Add gallery functionality
        const galleryButton = document.getElementById('gallery-button');
        const galleryModal = document.getElementById('gallery-modal');
        const closeButton = document.getElementById('close-gallery');

        galleryButton.addEventListener('click', () => {
            showGallery();
        });

        closeButton.addEventListener('click', () => {
            galleryModal.style.display = 'none';
        });

        function showGallery() {
            const content = document.getElementById('gallery-content');
            content.innerHTML = '';

            captures.forEach((capture) => {
                if (capture.type === 'video') {
                    content.innerHTML += `
                        <div class="gallery-item">
                            <video controls>
                                <source src="${capture.url}" type="video/mp4">
                            </video>
                            <small>${new Date(capture.timestamp).toLocaleString()}</small>
                        </div>
                    `;
                } else {
                    content.innerHTML += `
                        <div class="gallery-item">
                            <img src="${capture.url}" alt="Photo taken ${new Date(capture.timestamp).toLocaleString()}" />
                            <small>${new Date(capture.timestamp).toLocaleString()}</small>
                        </div>
                    `;
                }
            });

            galleryModal.style.display = 'flex';
        }

        // Initialize gallery
        async function initGallery() {
            try {
                const currentUser = await window.websim.getUser();
                const userDisplay = document.getElementById('user-display');
                const loginButton = document.getElementById('login-button');

                if (currentUser) {
                    // Show user info
                    userDisplay.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 8px; background: rgba(0, 0, 0, 0.5); padding: 8px 16px; border: 1px solid rgba(255, 255, 255, 0.1); margin-right: auto;">
                            <img src="https://images.websim.ai/avatar/${currentUser.username}" width="24" height="24">
                            <span>@${currentUser.username}</span>
                        </div>
                    `;
                    loginButton.textContent = 'Sign Out';

                    // Fetch projects        
                    const projects = await fetchUserProjects(currentUser);

                    if (projects) {
                        let cameraProject = projects.data.find(p => 
                            p.project.title?.toLowerCase().includes('camera')
                        );

                        if (!cameraProject) {
                            // Create new project if doesn't exist
                            cameraProject = await createCameraProject(currentUser);
                        }
 
                        if (cameraProject) {
                            await loadProjectAssets(cameraProject.project.id, captures);
                        }
                    }          
                } else {
                    // Show login button to sign in
                    userDisplay.innerHTML = '';
                    loginButton.textContent = 'Sign In';
                }

                loginButton.addEventListener('click', async () => {
                    if (!currentUser) {
                        window.location.href = `/oauth/login?redirect_uri=${encodeURIComponent(location.href)}`;
                    }
                });
            } catch (e) {
                console.error('Error initializing gallery:', e);
            }
        }

        // Helper functions
        async function createCameraProject(user) {
            const res = await fetch('/api/v1/projects', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    title: 'My Camera Photos',
                    description: 'Photos captured using Pixel Camera',
                    posted: true
                })
            });
            return res.json();
        }

        async function loadProjectAssets(projectId, storageArray) {
            return fetch(`api/v1/projects/${projectId}/revisions/1/assets`).then(res => res.json())
            .then(assets => {
                // Parse and sort assets
                return assets.assets.filter(asset => asset.path.startsWith('photos/') || asset.path.startsWith('videos/'))
                    .map(asset => ({
                        url: `https://images.websim.ai/v1/project/${projectId}/1/${asset.path}`,
                        timestamp: new Date(asset.created_at),
                        type: asset.path.startsWith('videos/') ? 'video' : 'photo'
                    }))
                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            });
        }

        async function fetchUserProjects(user) {
            try {
                const response = await fetch(`/api/v1/users/${user.username}/projects`);
                return await response.json();
            } catch (e) {
                console.error('Failed to fetch projects:', e);
                return null;
            }
        }

        async function savePhotoToProject(username, imageData) {
            try {
                const currentUser = await window.websim.getUser();
                if (!currentUser) {
                    // Save to local storage if not logged in
                    const captureObj = {
                        url: imageData,
                        timestamp: new Date(),
                        type: 'photo'
                    };
                    captures.unshift(captureObj);
                    localStorage.setItem('cameraCaptures', JSON.stringify(captures));
                    return;
                }

                const projects = await fetchUserProjects(currentUser);
                if (projects && projects.data && projects.data.length > 0) {
                    const project = projects.data[0].project;
                    const revisions = await getProjectRevisions(project.id);
                    if (revisions && revisions.data && revisions.data.length > 0) {
                        const latestRevision = revisions.data[0].project_revision;
                        const formData = new FormData();
                        const blob = await (await fetch(imageData)).blob();
                        const filename = `photos/${Date.now()}.jpg`;
                        formData.append('file', blob, filename);
                        
                        const response = await fetch(`/api/v1/projects/${project.id}/revisions/${latestRevision.version}/assets`, {
                            method: 'POST',
                            body: formData
                        });
                        
                        return await response.json();
                    }
                }
            } catch (e) {
                console.error('Failed to save photo:', e);
                // Fallback to local storage on error
                const captureObj = {
                    url: imageData,
                    timestamp: new Date(),
                    type: 'photo'
                };
                captures.unshift(captureObj);
                localStorage.setItem('cameraCaptures', JSON.stringify(captures));
            }
        }

        async function saveVideoToProject(currentUser, blob) {
            try {
                if (!currentUser) {
                    // Save to local storage if not logged in
                    const videoURL = URL.createObjectURL(blob);
                    const captureObj = {
                        url: videoURL,
                        timestamp: new Date(),
                        type: 'video'
                    };
                    captures.unshift(captureObj);
                    localStorage.setItem('cameraCaptures', JSON.stringify(captures));
                    return;
                }

                const projects = await fetchUserProjects(currentUser);
                if (projects && projects.data && projects.data.length > 0) {
                    const project = projects.data[0].project;
                    const revisions = await getProjectRevisions(project.id);
                    if (revisions && revisions.data && revisions.data.length > 0) {
                        const latestRevision = revisions.data[0].project_revision;
                        const formData = new FormData();
                        const filename = `videos/${Date.now()}.mp4`;
                        formData.append('file', blob, filename);
                        
                        const response = await fetch(`/api/v1/projects/${project.id}/revisions/${latestRevision.version}/assets`, {
                            method: 'POST',
                            body: formData
                        });
                        
                        return await response.json();
                    }
                }
            } catch (e) {
                console.error('Failed to save video:', e);
                // Fallback to local storage on error
                const videoURL = URL.createObjectURL(blob);
                const captureObj = {
                    url: videoURL,
                    timestamp: new Date(),
                    type: 'video'
                };
                captures.unshift(captureObj);
                localStorage.setItem('cameraCaptures', JSON.stringify(captures));
            }
        }

        async function getProjectRevisions(projectId) {
            try {
                const response = await fetch(`/api/v1/projects/${projectId}/revisions`);
                return await response.json();
            } catch (e) {
                console.error('Failed to fetch revisions:', e);
                return null;
            }
        }

        // Add focus functionality
        function initFocus() {
            const focusButton = document.getElementById('focus-button');
            focusButton.addEventListener('touchstart', startFocus);
        }

        async function startFocus() {
            focusActive = true;
            const videoTrack = videoEl.srcObject?.getVideoTracks()[0];
            if (videoTrack) {
                try {
                    await videoTrack.applyConstraints({});

                    showFocusFeedback();
                } catch (error) {
                    console.error('Focus failed:', error);
                }
            }
            focusActive = false;
        }

        function showFocusFeedback() {
            // visual/animation
        }

        function resetFocus() {
            focusActive = false;
        }

        // Optimized media recorder  
        let recordingshunks = [];

        function cleanupMediaRec() {
            if (videoEl.srcObject) {  
                URL.revokeObject(videoEl.srcObject);
            }
        }
    </script>
</body>
</html>